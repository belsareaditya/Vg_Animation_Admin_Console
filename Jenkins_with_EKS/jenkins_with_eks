pipeline {
  agent any

  tools {
    jdk 'jdk17'
    nodejs 'node23'
    terraform 'terraform-1.9'
  }

  environment {
    DOCKERHUB_USER = 'belsareaditya'
    IMAGE_NAME     = 'vault_guard'
    IMAGE_TAG      = "${DOCKERHUB_USER}/${IMAGE_NAME}:${env.BUILD_NUMBER}"

    AWS_REGION     = 'ap-south-1'
    TF_DIR         = 'Vg_Animation_Admin_Console/Terraform-Eks-Creation'
    CLUSTER_NAME   = 'vault_guard_cluster'

    EMAIL_TO       = 'belsareadityadevops@gmail.com'
    EMAIL_FROM     = 'belsareadityadevops@gmail.com'
  }

  stages {
    stage('Checkout') {
      steps {
        cleanWs()
        git branch: 'main', url: 'https://github.com/belsareaditya/Vg_Animation.git'
      }
    }

    stage('OWASP Dependency Check') {
      steps {
        dependencyCheck additionalArguments: '''
          --scan .
          --format XML
          --format HTML
          --out .
          --disableYarnAudit
          --disableNodeAudit
        ''',
        odcInstallation: 'dp-check'
        dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
      }
    }

    stage('Trivy Filesystem Scan') {
      steps {
        sh '''
          echo "ðŸ”Ž Trivy FS scan..."
          trivy fs . -f table -o trivy-fs.txt || true
          trivy fs . -f json  -o trivy-fs.json || true
        '''
      }
    }

    stage('Build Docker Image') {
      steps {
        sh '''
          echo "ðŸ”¨ Building Docker image..."
          docker rmi -f ${IMAGE_NAME} ${IMAGE_TAG} || true
          docker build -t ${IMAGE_NAME} .
        '''
      }
    }

    stage('Trivy Image Scan') {
      steps {
        sh '''
          echo "ðŸ§ª Trivy Image scan..."
          trivy image ${IMAGE_NAME} -f table -o trivy-image.txt || true
          trivy image ${IMAGE_NAME} -f json  -o trivy-image.json || true
        '''
      }
    }

    stage('Push Docker Image') {
      steps {
        withCredentials([string(credentialsId: 'docker-cred', variable: 'dockerpwd')]) {
          sh '''
            echo "${dockerpwd}" | docker login -u ${DOCKERHUB_USER} --password-stdin
            docker tag ${IMAGE_NAME} ${IMAGE_TAG}
            docker push ${IMAGE_TAG}
            docker tag ${IMAGE_NAME} ${DOCKERHUB_USER}/${IMAGE_NAME}:latest
            docker push ${DOCKERHUB_USER}/${IMAGE_NAME}:latest
          '''
        }
      }
    }

    stage('Terraform Init') {
      steps {
        withAWS(region: "${AWS_REGION}", credentials: 'aws-cred') {
          dir("${TF_DIR}") {
            sh '''
              echo "ðŸš€ Initializing Terraform..."
              terraform init -input=false
            '''
          }
        }
      }
    }

    stage('Terraform Apply VPC') {
      steps {
        withAWS(region: "${AWS_REGION}", credentials: 'aws-cred') {
          dir("${TF_DIR}") {
            sh '''
              echo "ðŸ”¨ Applying VPC module..."
              terraform apply -target=module.vpc -auto-approve
            '''
          }
        }
      }
    }

    stage('Terraform Apply EKS') {
      steps {
        withAWS(region: "${AWS_REGION}", credentials: 'aws-cred') {
          dir("${TF_DIR}") {
            sh '''
              echo "ðŸ”¨ Applying EKS module..."
              terraform apply -target=module.retail_app_eks -auto-approve
            '''
          }
        }
      }
    }

    stage('Update kubeconfig') {
      steps {
        withAWS(region: "${AWS_REGION}", credentials: 'aws-cred') {
          sh '''
            echo "ðŸ”§ Updating kubeconfig for EKS..."
            aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
            kubectl get nodes
          '''
        }
      }
    }

    stage('Deploy App on EKS') {
      steps {
        sh '''
          echo "ðŸš€ Deploying app into EKS cluster..."

          # Apply Deployment first
          kubectl apply -f kubernetes_manifest/vault_guard_k8.yaml

          # Update Deployment image to latest build
          kubectl set image deployment/vault-guard vault-guard=${IMAGE_TAG} --record

          # Apply Service second
          kubectl apply -f kubernetes_manifest/service.yaml

          # Wait for rollout to complete
          kubectl rollout status deployment/vault-guard
          kubectl get svc
        '''
      }
    }

    stage('Deploy Prometheus') {
      steps {
        sh '''
          echo "ðŸ“ˆ Deploying Prometheus via Helm..."
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm upgrade --install prometheus prometheus-community/prometheus \
            --namespace monitoring --create-namespace \
            --set server.service.type=LoadBalancer

          kubectl get svc -n monitoring
        '''
      }
    }

    stage('Deploy Grafana') {
      steps {
        sh '''
          echo "ðŸ“Š Deploying Grafana via Helm with Prometheus datasource + dashboards..."

          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update

          cat > grafana-values.yaml <<EOF
          adminPassword: "admin123"
          service:
            type: LoadBalancer
          datasources:
            datasources.yaml:
              apiVersion: 1
              datasources:
                - name: Prometheus
                  type: prometheus
                  access: proxy
                  url: http://prometheus-server.monitoring.svc.cluster.local
                  isDefault: true
          dashboardProviders:
            dashboardproviders.yaml:
              apiVersion: 1
              providers:
              - name: 'default'
                orgId: 1
                folder: ''
                type: file
                disableDeletion: false
                editable: true
                options:
                  path: /var/lib/grafana/dashboards/default
          dashboards:
            default:
              k8s-cluster:
                gnetId: 6417
                revision: 1
                datasource: Prometheus
              node-exporter-full:
                gnetId: 1860
                revision: 29
                datasource: Prometheus
          EOF

          helm upgrade --install grafana grafana/grafana \
            --namespace monitoring --create-namespace \
            -f grafana-values.yaml

          kubectl get svc -n monitoring
        '''
      }
    }
  }

  post {
    always {
      script {
        archiveArtifacts allowEmptyArchive: true, artifacts: 'trivy-*.txt,trivy-*.json,dependency-check-report.*'

        def status = currentBuild.currentResult
        emailext(
          to: "${EMAIL_TO}",
          from: "${EMAIL_FROM}",
          subject: "Jenkins ${status}: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
          mimeType: 'text/html',
          body: """
            <p><b>${env.JOB_NAME}</b> #<b>${env.BUILD_NUMBER}</b> finished with: <b>${status}</b></p>
            <ul>
              <li>Image: <code>${IMAGE_TAG}</code></li>
              <li>EKS Cluster: <code>${CLUSTER_NAME}</code></li>
              <li>Region: <code>${AWS_REGION}</code></li>
              <li>Monitoring: Prometheus + Grafana deployed in <code>monitoring</code> namespace</li>
              <li>Build: <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></li>
              <li>Artifacts: <a href="${env.BUILD_URL}artifact">download</a></li>
              <li>Console: <a href="${env.BUILD_URL}console">view</a></li>
            </ul>
          """,
          attachmentsPattern: '',
          attachLog: false,
          compressLog: false
        )
      }
    }
  }
}
